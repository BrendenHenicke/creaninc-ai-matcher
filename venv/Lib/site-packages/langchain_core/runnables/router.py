"""Runnable that routes to a set of Runnables."""

from __future__ import annotations

<<<<<<< HEAD
from collections.abc import Mapping
from itertools import starmap
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Optional,
    Union,
=======
from collections.abc import Callable, Mapping
from typing import (
    TYPE_CHECKING,
    Any,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    cast,
)

from pydantic import ConfigDict
from typing_extensions import TypedDict, override

from langchain_core.runnables.base import (
    Runnable,
    RunnableSerializable,
    coerce_to_runnable,
)
from langchain_core.runnables.config import (
    RunnableConfig,
    get_config_list,
    get_executor_for_config,
)
from langchain_core.runnables.utils import (
    ConfigurableFieldSpec,
    Input,
    Output,
    gather_with_concurrency,
    get_unique_config_specs,
)

if TYPE_CHECKING:
    from collections.abc import AsyncIterator, Iterator


class RouterInput(TypedDict):
<<<<<<< HEAD
    """Router input.

    Attributes:
        key: The key to route on.
        input: The input to pass to the selected Runnable.
    """

    key: str
    input: Any
=======
    """Router input."""

    key: str
    """The key to route on."""
    input: Any
    """The input to pass to the selected Runnable."""
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)


class RouterRunnable(RunnableSerializable[RouterInput, Output]):
    """Runnable that routes to a set of Runnables based on Input['key'].

    Returns the output of the selected Runnable.

    Example:
<<<<<<< HEAD

        .. code-block:: python

            from langchain_core.runnables.router import RouterRunnable
            from langchain_core.runnables import RunnableLambda

            add = RunnableLambda(func=lambda x: x + 1)
            square = RunnableLambda(func=lambda x: x**2)

            router = RouterRunnable(runnables={"add": add, "square": square})
            router.invoke({"key": "square", "input": 3})
=======
        ```python
        from langchain_core.runnables.router import RouterRunnable
        from langchain_core.runnables import RunnableLambda

        add = RunnableLambda(func=lambda x: x + 1)
        square = RunnableLambda(func=lambda x: x**2)

        router = RouterRunnable(runnables={"add": add, "square": square})
        router.invoke({"key": "square", "input": 3})
        ```
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    """

    runnables: Mapping[str, Runnable[Any, Output]]

    @property
    @override
    def config_specs(self) -> list[ConfigurableFieldSpec]:
        return get_unique_config_specs(
            spec for step in self.runnables.values() for spec in step.config_specs
        )

    def __init__(
        self,
<<<<<<< HEAD
        runnables: Mapping[str, Union[Runnable[Any, Output], Callable[[Any], Output]]],
=======
        runnables: Mapping[str, Runnable[Any, Output] | Callable[[Any], Output]],
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> None:
        """Create a RouterRunnable.

        Args:
            runnables: A mapping of keys to Runnables.
        """
<<<<<<< HEAD
        super().__init__(  # type: ignore[call-arg]
=======
        super().__init__(
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            runnables={key: coerce_to_runnable(r) for key, r in runnables.items()}
        )

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
    )

    @classmethod
    @override
    def is_lc_serializable(cls) -> bool:
<<<<<<< HEAD
        """Return whether this class is serializable."""
=======
        """Return True as this class is serializable."""
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
        return True

    @classmethod
    @override
    def get_lc_namespace(cls) -> list[str]:
<<<<<<< HEAD
        """Get the namespace of the langchain object."""
=======
        """Get the namespace of the LangChain object.

        Returns:
            `["langchain", "schema", "runnable"]`
        """
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
        return ["langchain", "schema", "runnable"]

    @override
    def invoke(
<<<<<<< HEAD
        self, input: RouterInput, config: Optional[RunnableConfig] = None, **kwargs: Any
=======
        self, input: RouterInput, config: RunnableConfig | None = None, **kwargs: Any
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> Output:
        key = input["key"]
        actual_input = input["input"]
        if key not in self.runnables:
            msg = f"No runnable associated with key '{key}'"
            raise ValueError(msg)

        runnable = self.runnables[key]
        return runnable.invoke(actual_input, config)

    @override
    async def ainvoke(
        self,
        input: RouterInput,
<<<<<<< HEAD
        config: Optional[RunnableConfig] = None,
        **kwargs: Optional[Any],
=======
        config: RunnableConfig | None = None,
        **kwargs: Any | None,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> Output:
        key = input["key"]
        actual_input = input["input"]
        if key not in self.runnables:
            msg = f"No runnable associated with key '{key}'"
            raise ValueError(msg)

        runnable = self.runnables[key]
        return await runnable.ainvoke(actual_input, config)

    @override
    def batch(
        self,
        inputs: list[RouterInput],
<<<<<<< HEAD
        config: Optional[Union[RunnableConfig, list[RunnableConfig]]] = None,
        *,
        return_exceptions: bool = False,
        **kwargs: Optional[Any],
=======
        config: RunnableConfig | list[RunnableConfig] | None = None,
        *,
        return_exceptions: bool = False,
        **kwargs: Any | None,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> list[Output]:
        if not inputs:
            return []

        keys = [input_["key"] for input_ in inputs]
        actual_inputs = [input_["input"] for input_ in inputs]
        if any(key not in self.runnables for key in keys):
            msg = "One or more keys do not have a corresponding runnable"
            raise ValueError(msg)

        def invoke(
            runnable: Runnable, input_: Input, config: RunnableConfig
<<<<<<< HEAD
        ) -> Union[Output, Exception]:
=======
        ) -> Output | Exception:
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            if return_exceptions:
                try:
                    return runnable.invoke(input_, config, **kwargs)
                except Exception as e:
                    return e
            else:
                return runnable.invoke(input_, config, **kwargs)

        runnables = [self.runnables[key] for key in keys]
        configs = get_config_list(config, len(inputs))
        with get_executor_for_config(configs[0]) as executor:
            return cast(
                "list[Output]",
                list(executor.map(invoke, runnables, actual_inputs, configs)),
            )

    @override
    async def abatch(
        self,
        inputs: list[RouterInput],
<<<<<<< HEAD
        config: Optional[Union[RunnableConfig, list[RunnableConfig]]] = None,
        *,
        return_exceptions: bool = False,
        **kwargs: Optional[Any],
=======
        config: RunnableConfig | list[RunnableConfig] | None = None,
        *,
        return_exceptions: bool = False,
        **kwargs: Any | None,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> list[Output]:
        if not inputs:
            return []

        keys = [input_["key"] for input_ in inputs]
        actual_inputs = [input_["input"] for input_ in inputs]
        if any(key not in self.runnables for key in keys):
            msg = "One or more keys do not have a corresponding runnable"
            raise ValueError(msg)

        async def ainvoke(
            runnable: Runnable, input_: Input, config: RunnableConfig
<<<<<<< HEAD
        ) -> Union[Output, Exception]:
=======
        ) -> Output | Exception:
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            if return_exceptions:
                try:
                    return await runnable.ainvoke(input_, config, **kwargs)
                except Exception as e:
                    return e
            else:
                return await runnable.ainvoke(input_, config, **kwargs)

        runnables = [self.runnables[key] for key in keys]
        configs = get_config_list(config, len(inputs))
        return await gather_with_concurrency(
            configs[0].get("max_concurrency"),
<<<<<<< HEAD
            *starmap(ainvoke, zip(runnables, actual_inputs, configs)),
=======
            *map(ainvoke, runnables, actual_inputs, configs),
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
        )

    @override
    def stream(
        self,
        input: RouterInput,
<<<<<<< HEAD
        config: Optional[RunnableConfig] = None,
        **kwargs: Optional[Any],
=======
        config: RunnableConfig | None = None,
        **kwargs: Any | None,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> Iterator[Output]:
        key = input["key"]
        actual_input = input["input"]
        if key not in self.runnables:
            msg = f"No runnable associated with key '{key}'"
            raise ValueError(msg)

        runnable = self.runnables[key]
        yield from runnable.stream(actual_input, config)

    @override
    async def astream(
        self,
        input: RouterInput,
<<<<<<< HEAD
        config: Optional[RunnableConfig] = None,
        **kwargs: Optional[Any],
=======
        config: RunnableConfig | None = None,
        **kwargs: Any | None,
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    ) -> AsyncIterator[Output]:
        key = input["key"]
        actual_input = input["input"]
        if key not in self.runnables:
            msg = f"No runnable associated with key '{key}'"
            raise ValueError(msg)

        runnable = self.runnables[key]
        async for output in runnable.astream(actual_input, config):
            yield output
