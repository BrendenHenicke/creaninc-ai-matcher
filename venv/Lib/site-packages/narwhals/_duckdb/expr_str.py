from __future__ import annotations

from typing import TYPE_CHECKING

<<<<<<< HEAD
from duckdb import FunctionExpression

from narwhals._duckdb.utils import lit
from narwhals.utils import not_implemented
=======
from narwhals._duckdb.utils import F, col, concat_str, lit
from narwhals._sql.expr_str import SQLExprStringNamespace
from narwhals._utils import not_implemented, requires
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)

if TYPE_CHECKING:
    from duckdb import Expression

    from narwhals._duckdb.expr import DuckDBExpr


<<<<<<< HEAD
class DuckDBExprStringNamespace:
    def __init__(self, expr: DuckDBExpr) -> None:
        self._compliant_expr = expr

    def starts_with(self, prefix: str) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("starts_with", expr, lit(prefix))
        )

    def ends_with(self, suffix: str) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("ends_with", expr, lit(suffix))
        )

    def contains(self, pattern: str, *, literal: bool) -> DuckDBExpr:
        def func(expr: Expression) -> Expression:
            if literal:
                return FunctionExpression("contains", expr, lit(pattern))
            return FunctionExpression("regexp_matches", expr, lit(pattern))

        return self._compliant_expr._with_callable(func)

    def slice(self, offset: int, length: int) -> DuckDBExpr:
        def func(expr: Expression) -> Expression:
            offset_lit = lit(offset)
            return FunctionExpression(
                "array_slice",
                expr,
                lit(offset + 1)
                if offset >= 0
                else FunctionExpression("length", expr) + offset_lit + lit(1),
                FunctionExpression("length", expr)
                if length is None
                else lit(length) + offset_lit,
            )

        return self._compliant_expr._with_callable(func)

    def split(self, by: str) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("str_split", expr, lit(by))
        )

    def len_chars(self) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("length", expr)
        )

    def to_lowercase(self) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("lower", expr)
        )

    def to_uppercase(self) -> DuckDBExpr:
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("upper", expr)
        )

    def strip_chars(self, characters: str | None) -> DuckDBExpr:
        import string

        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression(
                "trim", expr, lit(string.whitespace if characters is None else characters)
            )
        )

    def replace_all(self, pattern: str, value: str, *, literal: bool) -> DuckDBExpr:
        if not literal:
            return self._compliant_expr._with_callable(
                lambda expr: FunctionExpression(
                    "regexp_replace", expr, lit(pattern), lit(value), lit("g")
                )
            )
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("replace", expr, lit(pattern), lit(value))
        )

=======
class DuckDBExprStringNamespace(SQLExprStringNamespace["DuckDBExpr"]):
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    def to_datetime(self, format: str | None) -> DuckDBExpr:
        if format is None:
            msg = "Cannot infer format with DuckDB backend, please specify `format` explicitly."
            raise NotImplementedError(msg)

<<<<<<< HEAD
        return self._compliant_expr._with_callable(
            lambda expr: FunctionExpression("strptime", expr, lit(format))
        )

=======
        return self.compliant._with_elementwise(
            lambda expr: F("strptime", expr, lit(format))
        )

    def to_date(self, format: str | None) -> DuckDBExpr:
        if format is not None:
            return self.to_datetime(format=format).dt.date()

        compliant_expr = self.compliant
        return compliant_expr.cast(compliant_expr._version.dtypes.Date())

    @requires.backend_version((1, 2))
    def to_titlecase(self) -> DuckDBExpr:
        from narwhals._duckdb.utils import lambda_expr

        def _to_titlecase(expr: Expression) -> Expression:
            extract_expr = F(
                "regexp_extract_all", F("lower", expr), lit(r"[a-z0-9]*[^a-z0-9]*")
            )
            elem = col("_")
            capitalize = lambda_expr(
                elem,
                concat_str(
                    F("upper", F("array_extract", elem, lit(1))),
                    F("substring", elem, lit(2)),
                ),
            )
            capitalized_expr = F("list_transform", extract_expr, capitalize)
            return F("list_aggregate", capitalized_expr, lit("string_agg"), lit(""))

        return self.compliant._with_elementwise(_to_titlecase)

>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    replace = not_implemented()
