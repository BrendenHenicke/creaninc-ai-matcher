from __future__ import annotations

import operator
from functools import reduce
from itertools import chain
<<<<<<< HEAD
from typing import TYPE_CHECKING, Iterable, Sequence

import duckdb
from duckdb import CoalesceOperator, Expression, FunctionExpression
from duckdb.typing import BIGINT, VARCHAR

from narwhals._compliant import CompliantThen, LazyNamespace, LazyWhen
from narwhals._duckdb.dataframe import DuckDBLazyFrame
from narwhals._duckdb.expr import DuckDBExpr
from narwhals._duckdb.selectors import DuckDBSelectorNamespace
from narwhals._duckdb.utils import concat_str, lit, narwhals_to_native_dtype, when
=======
from typing import TYPE_CHECKING, Any

import duckdb
from duckdb import CoalesceOperator, Expression

from narwhals._duckdb.dataframe import DuckDBLazyFrame
from narwhals._duckdb.expr import DuckDBExpr
from narwhals._duckdb.selectors import DuckDBSelectorNamespace
from narwhals._duckdb.utils import (
    DeferredTimeZone,
    F,
    concat_str,
    duckdb_dtypes,
    function,
    lit,
    narwhals_to_native_dtype,
    when,
)
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
from narwhals._expression_parsing import (
    combine_alias_output_names,
    combine_evaluate_output_names,
)
<<<<<<< HEAD
from narwhals.utils import Implementation

if TYPE_CHECKING:
    from narwhals.dtypes import DType
    from narwhals.typing import ConcatMethod, NonNestedLiteral
    from narwhals.utils import Version


class DuckDBNamespace(
    LazyNamespace[DuckDBLazyFrame, DuckDBExpr, duckdb.DuckDBPyRelation]
):
    _implementation: Implementation = Implementation.DUCKDB

    def __init__(self, *, backend_version: tuple[int, ...], version: Version) -> None:
        self._backend_version = backend_version
=======
from narwhals._sql.namespace import SQLNamespace
from narwhals._sql.when_then import SQLThen, SQLWhen
from narwhals._utils import Implementation

if TYPE_CHECKING:
    from collections.abc import Iterable

    from duckdb import DuckDBPyRelation  # noqa: F401

    from narwhals._utils import Version
    from narwhals.typing import ConcatMethod, IntoDType, NonNestedLiteral

VARCHAR = duckdb_dtypes.VARCHAR


class DuckDBNamespace(
    SQLNamespace[DuckDBLazyFrame, DuckDBExpr, "DuckDBPyRelation", Expression]
):
    _implementation: Implementation = Implementation.DUCKDB

    def __init__(self, *, version: Version) -> None:
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
        self._version = version

    @property
    def selectors(self) -> DuckDBSelectorNamespace:
        return DuckDBSelectorNamespace.from_namespace(self)

    @property
    def _expr(self) -> type[DuckDBExpr]:
        return DuckDBExpr

    @property
    def _lazyframe(self) -> type[DuckDBLazyFrame]:
        return DuckDBLazyFrame

<<<<<<< HEAD
=======
    def _function(self, name: str, *args: Expression) -> Expression:  # type: ignore[override]
        return function(name, *args)

    def _lit(self, value: Any) -> Expression:
        return lit(value)

    def _when(
        self,
        condition: Expression,
        value: Expression,
        otherwise: Expression | None = None,
    ) -> Expression:
        if otherwise is None:
            return when(condition, value)
        return when(condition, value).otherwise(otherwise)

    def _coalesce(self, *exprs: Expression) -> Expression:
        return CoalesceOperator(*exprs)

>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    def concat(
        self, items: Iterable[DuckDBLazyFrame], *, how: ConcatMethod
    ) -> DuckDBLazyFrame:
        native_items = [item._native_frame for item in items]
        items = list(items)
        first = items[0]
        schema = first.schema
        if how == "vertical" and not all(x.schema == schema for x in items[1:]):
            msg = "inputs should all have the same schema"
            raise TypeError(msg)
<<<<<<< HEAD
=======
        if how == "diagonal":
            res = first.native
            for _item in native_items[1:]:
                # TODO(unassigned): use relational API when available https://github.com/duckdb/duckdb/discussions/16996
                res = duckdb.sql("""
                    from res select * union all by name from _item select *
                """)
            return first._with_native(res)
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
        res = reduce(lambda x, y: x.union(y), native_items)
        return first._with_native(res)

    def concat_str(
        self, *exprs: DuckDBExpr, separator: str, ignore_nulls: bool
    ) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
<<<<<<< HEAD
            cols = list(chain.from_iterable(expr(df) for expr in exprs))
            if not ignore_nulls:
                null_mask_result = reduce(operator.or_, (s.isnull() for s in cols))
                cols_separated = [
                    y
                    for x in [
                        (col.cast(VARCHAR),)
                        if i == len(cols) - 1
                        else (col.cast(VARCHAR), lit(separator))
                        for i, col in enumerate(cols)
                    ]
                    for y in x
                ]
                return [when(~null_mask_result, concat_str(*cols_separated))]
            else:
                return [concat_str(*cols, separator=separator)]
=======
            cols: Iterable[Expression] = chain.from_iterable(e(df) for e in exprs)
            if ignore_nulls:
                return [concat_str(*cols, separator=separator)]
            cols = tuple(cols)
            null_mask = reduce(operator.or_, (s.isnull() for s in cols))
            cols_str = (c.cast(VARCHAR) for c in cols)
            return [when(~null_mask, concat_str(*cols_str, separator=separator))]
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
<<<<<<< HEAD
            backend_version=self._backend_version,
            version=self._version,
        )

    def all_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = (c for _expr in exprs for c in _expr(df))
            return [reduce(operator.and_, cols)]

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
            version=self._version,
        )

    def any_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = (c for _expr in exprs for c in _expr(df))
            return [reduce(operator.or_, cols)]

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
            version=self._version,
        )

    def max_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = (c for _expr in exprs for c in _expr(df))
            return [FunctionExpression("greatest", *cols)]

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
            version=self._version,
        )

    def min_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = (c for _expr in exprs for c in _expr(df))
            return [FunctionExpression("least", *cols)]

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
            version=self._version,
        )

    def sum_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = (CoalesceOperator(col, lit(0)) for _expr in exprs for col in _expr(df))
            return [reduce(operator.add, cols)]

        return self._expr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
=======
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            version=self._version,
        )

    def mean_horizontal(self, *exprs: DuckDBExpr) -> DuckDBExpr:
<<<<<<< HEAD
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            cols = [c for _expr in exprs for c in _expr(df)]
            return [
                (
                    reduce(operator.add, (CoalesceOperator(col, lit(0)) for col in cols))
                    / reduce(operator.add, (col.isnotnull().cast(BIGINT) for col in cols))
                )
            ]

        return DuckDBExpr(
            call=func,
            evaluate_output_names=combine_evaluate_output_names(*exprs),
            alias_output_names=combine_alias_output_names(*exprs),
            backend_version=self._backend_version,
            version=self._version,
        )
=======
        def func(cols: Iterable[Expression]) -> Expression:
            cols = tuple(cols)
            total = reduce(operator.add, (CoalesceOperator(col, lit(0)) for col in cols))
            count = reduce(
                operator.add, (col.isnotnull().cast(duckdb_dtypes.BIGINT) for col in cols)
            )
            return total / count

        return self._expr._from_elementwise_horizontal_op(func, *exprs)
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)

    def when(self, predicate: DuckDBExpr) -> DuckDBWhen:
        return DuckDBWhen.from_expr(predicate, context=self)

<<<<<<< HEAD
    def lit(
        self, value: NonNestedLiteral, dtype: DType | type[DType] | None
    ) -> DuckDBExpr:
        def func(_df: DuckDBLazyFrame) -> list[Expression]:
            if dtype is not None:
                return [
                    lit(value).cast(
                        narwhals_to_native_dtype(dtype, version=self._version)  # type: ignore[arg-type]
                    )
                ]
=======
    def lit(self, value: NonNestedLiteral, dtype: IntoDType | None) -> DuckDBExpr:
        def func(df: DuckDBLazyFrame) -> list[Expression]:
            tz = DeferredTimeZone(df.native)
            if dtype is not None:
                target = narwhals_to_native_dtype(dtype, self._version, tz)
                return [lit(value).cast(target)]
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            return [lit(value)]

        return self._expr(
            func,
            evaluate_output_names=lambda _df: ["literal"],
            alias_output_names=None,
<<<<<<< HEAD
            backend_version=self._backend_version,
=======
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            version=self._version,
        )

    def len(self) -> DuckDBExpr:
        def func(_df: DuckDBLazyFrame) -> list[Expression]:
<<<<<<< HEAD
            return [FunctionExpression("count")]
=======
            return [F("count")]
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)

        return self._expr(
            call=func,
            evaluate_output_names=lambda _df: ["len"],
            alias_output_names=None,
<<<<<<< HEAD
            backend_version=self._backend_version,
=======
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
            version=self._version,
        )


<<<<<<< HEAD
class DuckDBWhen(LazyWhen["DuckDBLazyFrame", Expression, DuckDBExpr]):
=======
class DuckDBWhen(SQLWhen["DuckDBLazyFrame", Expression, DuckDBExpr]):
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
    @property
    def _then(self) -> type[DuckDBThen]:
        return DuckDBThen

<<<<<<< HEAD
    def __call__(self, df: DuckDBLazyFrame) -> Sequence[Expression]:
        self.when = when
        self.lit = lit
        return super().__call__(df)


class DuckDBThen(
    CompliantThen["DuckDBLazyFrame", Expression, DuckDBExpr], DuckDBExpr
): ...
=======

class DuckDBThen(SQLThen["DuckDBLazyFrame", Expression, DuckDBExpr], DuckDBExpr): ...
>>>>>>> 10771d2d (Initial commit for Crean AI Matcher full app)
